1. Selenium Architecture
there are 3 main part
clint library, browser driver and actual driver

Client libraries provide various methods to perform different browser actions. e.g. get, title,find_element
Once we execute the script, the client libraries convert our code that we have written into a JSON (JavaScript Object Notation) format and sent as a request to Driver over HTTP.
Each browser driver will be maintained by respective browser vendor.
The driver interprets the incoming request from the client and controls the actual browser.
Once the browser operation is complete, the response is sent back to the client/client library by driver in JSON format.
---------------------------------------------------------------------------------------------------------
2. Latest version  of Selenium - 4.0
---------------------------------------------------------------------------------------------------------
3. Difference between close() and quit()
* close() closes only the current window on which Selenium is running automated tests. The WebDriver session, however remains active.
driver.close()

* quit() method closes all browser windows and ends the WebDriver session.
driver. quit()
---------------------------------------------------------------------------------------------------------
4. How do you write parent and child in XPath?
Start by writing out the selenium Xpath for the parent and then traverse to desired object using backslashes like so
E.g.
//a[text()='Fiction']/../..//input[@type='checkbox']
//a[@id='nav-logo-sprites']/../../../..     Traversing to parent

* .. to refer to the parent node
* / to indicate the immediate child node
* // to denote any descendant node, regardless of depth
---------------------------------------------------------------------------------------------------------
5. What is css locator and xpath
CSS: In Selenium, CSS locators are one of the primary methods used to identify and interact with elements on a web page.
CSS locators use CSS selectors to find elements based on their attributes, IDs, classes, or other properties. Here are some examples of CSS locators:

Syntax:
HTMLTAG[attribute=‘attribute_value’]

a[class='ico-register’]
input[id='gender-male’]
input[name='FirstName’]

XPATH: In Selenium, XPath is another powerful locator strategy to identify elements on a web page using XML path expressions. 
XPath allows you to navigate through the XML structure of a webpage and pinpoint elements based on their attributes, text, position, and more.
Syntax:
//HTMLTAG[@attribute='value’]

* Absolute XPath:
Begins from the root node of the document (/html) and traces the path down to the desired element.
Less preferable because it can become brittle if the structure of the webpage changes.
E.g. element = driver.find_element_by_xpath("/html/body/div[1]/div[2]/form/input")

* Relative XPath:
Begins its path selection from the context node (usually starts with //).
More adaptable as it's based on the structure of the element rather than the entire document.
E.g. element = driver.find_element_by_xpath("//form/input")
---------------------------------------------------------------------------------------------------------
5. Write xpath for a scenario
from selenium import webdriver
from time import sleep
from selenium.webdriver.common.keys import Keys

driver = webdriver.Chrome(r"C:\Users\srikanth\Desktop\IT\Testing\chromedriver_win32\chromedriver.exe")
sleep(3)
driver.maximize_window()
driver.get("https://www.google.co.in")
sleep(3)
driver.find_element_by_xpath("//input[@class='gLFyf gsfi']").send_keys('Rohit sharma', Keys.ENTER)

print(driver.title)
print(driver.current_url)

# driver.close()      # close current browser
# driver.quit()       # close all browser
---------------------------------------------------------------------------------------------------------
6. Dependent and independent writing xpath
* Independent XPaths are those that directly target the element based on its unique attributes, properties, or location within the DOM.
element = driver.find_element_by_xpath("//input[@id='username']")

* Dependent XPaths rely on the structure or hierarchy of elements in the DOM. They are more susceptible to breaking if there are changes in the structure or additional elements added/removed from the webpage.
element = driver.find_element_by_xpath("//div[2]/input")
---------------------------------------------------------------------------------------------------------
7. How do you read data from webtable
This code locates the table by its ID, finds all rows (<tr>) within that table, then iterates through each row and extracts the text content from each cell (<td>) using cell.text.
---------------------------------------------------------------------------------------------------------
8. How do you check if the contents of the table are in sorted order or not

# Find the table element
table = driver.find_element_by_id("myTable")

# Get all rows from the table
rows = table.find_elements_by_tag_name("tr")

# Get data from a specific column (let's assume it's the second column)
data = []
for row in rows[1:]:  # Skip the first row as it's likely the header
    cells = row.find_elements_by_tag_name("td")
    data.append(int(cells[1].text))         # Assuming the second column has numeric values

# Check if the data is sorted in ascending order
is_sorted = all(data[i] <= data[i + 1] for i in range(len(data) - 1))

if is_sorted:
    print("The data in the table is sorted in ascending order.")
else:
    print("The data in the table is not sorted in ascending order.")
---------------------------------------------------------------------------------------------------------
9. which is best locator in selenium
ID locator in Selenium is the most preferred and fastest way to locate desired WebElements on the page.
ID Selenium locators are unique for each element in the DOM.
---------------------------------------------------------------------------------------------------------
10. What is test automation or automation testing?
Automation testing enables the use of specialized tools to automate the execution of manually designed test cases without any human intervention.
---------------------------------------------------------------------------------------------------------
11. css locator - Why css is the Fastest locator?
* Xpath allows bidirectional flow which means the traversal can be both ways from parent to child and child to parent as well.
* Css allows only one directional flow which means the traversal is from parent to child only.
---------------------------------------------------------------------------------------------------------
12. Exceptions in selenium.
* NoSuchElementException: This exception is raised when the element is not found in DOM
* StaleElementException: Thrown when a reference to an element is now "stale" or Lost
* NoSuchAttributeException: Thrown when the attribute of element could not be found
* NoAlertPresentException: when the driver in the Selenium Program code is unable to find the Alert on the web page to switch.
* UnexpectedTagNameException: Thrown when you try to create an instance of Select class by passing a webelement where the HTML tag is other than <select>
* ElementNotVisibleException: Thrown when an element is present on the DOM, but it is not visible
* ElementNotInteractableException: Thrown when an element is present on the DOM but can not interaction with the element
* TimeoutException:
* NoSuchFrameException:
---------------------------------------------------------------------------------------------------------
13. Mouse actions in selenium
Actions class is an ability provided by Selenium for handling keyboard and mouse events.
The Five mouse actions are Left Click, Right Click, Double Click, Drag & Drop, and Scroll.

Mouse Actions in Selenium:

1. doubleClick(): Performs double click on the element
    action.double_click()
2. clickAndHold(): Performs long click on the mouse without releasing it
    action.click_and_hold()
3. dragAndDrop(): Drags the element from one point and drops to another
    action.drag_and_drop()
4. moveToElement(): Shifts the mouse pointer to the center of the element
    action.move_to_element()
5. contextClick(): Performs right-click on the mouse
    action.context_click()
6. send_keys: The sendKeys(CharSequence KeysToSend) method is used to send a sequence of keys to a currently focussed web
element. By using this we can page up, page down, enter, tab, escape task can we perform
    action.send_keys
---------------------------------------------------------------------------------------------------------
14. What are the advantages of automation testing?
Automation testing supports both functional and performance test on an application.
It supports the execution of repeated test cases.
It facilitates parallel execution.
It aids in testing a large test matrix.
It improves accuracy because there are no chances of human errors.
It saves time and money.
---------------------------------------------------------------------------------------------------------
15. What is Selenium?
Selenium is a test framework for web application automation testing. It supports multiple browsers and is OS independent. Selenium also supports various programming languages like Java, C#, PHP, Ruby, and Perl, etc.
---------------------------------------------------------------------------------------------------------
16. What are the different components of Selenium?
Selenium IDE: is primarily a record/run tool that a test case developer uses to develop Selenium Test cases.
Selenium Remote Control: It is basically a server that allows to create test scripts in multiple programming languages and browsers.
Selenium Web driver: Selenium WebDriver runs on various browsers like Chrome, IE, Safari and Firefox and so on.
Selenium GRID: we can execute scripts in parallel
---------------------------------------------------------------------------------------------------------
17. List out the names of programming languages, browsers and operating systems that are supported by Selenium.
Programming Languages: C#, Java, Python, PHP, Ruby, Perl, JavaScript.
Operating Systems: Android, iOS, Windows, Linux, Mac, Solaris.
Browsers: Google Chrome, Mozilla Firefox, Internet Explorer, Edge, Opera, Safari, etc.
---------------------------------------------------------------------------------------------------------
18. What are the significant changes/upgrades in various Selenium versions?
---------------------------------------------------------------------------------------------------------
19. List the test types that are supported by Selenium.
Functional Testing
Regression Testing
Sanity Testing
Smoke Testing
Responsive Testing
Cross Browser Testing
UI testing (black box)
Integration Testing
---------------------------------------------------------------------------------------------------------
20. What are the different ways of locating a web element in Selenium?
name, id, class, text, xpath, css, partial text, tag name
---------------------------------------------------------------------------------------------------------
21. What is meant by Selenese? Explain different types of Selenium commands.
The language used for writing test scripts in Selenium IDE is called Selenese. It is a set of commands used
to test your web application or system. Selenium commands could be divided into 3 major categories:

Actions: These are the commands interacting directly with web applications.
Accessors: These are the commands which allow users to store values to a user-defined variable.
Assertions: They enable a comparison of the current state of the application with its expected state.
---------------------------------------------------------------------------------------------------------
22. What do you mean by the assertion in Selenium
The assertion is used as a verification point. It verifies that the state of the application confirms to what is expected.
The types of assertion are "assert", "verify" and "waitFor".
---------------------------------------------------------------------------------------------------------
23. Explain the difference between assert and verify commands?
Assert: Assert command checks if the given condition is true or false. If the condition is true, the program control will execute the next phase of testing, and if the condition is false, execution will stop, and nothing will be executed.
def func(n):
    return n+1

def test_answer():
    assert func(3) == 4

Verify: Verify command also checks if the given condition is true or false. It doesn't halt program execution,
i.e., any failure during verification would not stop the execution, and all the test phases would be executed.
---------------------------------------------------------------------------------------------------------
24. How do you verify the color of the web element
@property color
.value_of_css_property(background_color)
---------------------------------------------------------------------------------------------------------
25. How do you get the location and size of a particular web element.
xpath.size and xpath.location
---------------------------------------------------------------------------------------------------------
26. What do you mean by XPath?
---------------------------------------------------------------------------------------------------------
27. Difference between absolute xpath and relative xpath
* Absolute: XPath Absolute enables users to mention the complete XPath location from the root HTML tag to the specific elements.
Example: //html/body/div[2]/div/div[2]/div/div/div/fieldset/form/div[1]/input[1]

* Relative: is always recommended when you don't have a suitable id or name attribute for the element you want to locate.
Relative Xpath starts with double forward slash (//), meaning the element can be searched any where in the webpage.
---------------------------------------------------------------------------------------------------------
28. What is the difference between "/" and "//" in XPath?
Single Slash "/": Single slash is used to create XPath with absolute path. To get immediate child.
Double Slash "//": Double slash is used to create XPath with the relative path. To get any child.
---------------------------------------------------------------------------------------------------------
29. Difference between findElement and findElements
* findElement can pinpoint only one element. The findElement method throws a NoSuchElementException exception when the element is not available on the page.
* findElements method returns the list of all matching elements.Whereas, the findElements method returns an empty list when the element is not available or doesn't exist on the page
---------------------------------------------------------------------------------------------------------
30. Difference between implicit wait and explicit wait
Synchronization: when two or more components involved to perform any action, we expect these components to work together with the same pace. The co-ordination between these components to run parallel is called Synchronization.

Selenium Python tries to find the element without bothering about whether elements are loaded or not, and
selenium python throws NoSuchElementException if the element is not present.

a. Explicit wait
* Explicit Wait time is applied only to those elements which are intended by us
* An explicit wait makes WebDriver wait for a certain condition to occur before proceeding further with execution.
* 'visibility_of_element_located' checks if the web element is present on the DOM and also visible on the webpage.
* "TimeoutException" will be raised if either the element is not loaded onto the DOM or the element is not visible on the web page within timeout period.
* sleep() i.e. a static wait that will halt the test execution for some specified time and then perform the next step.

b. Implicitly wait
* Implicit Wait time is applied to all the elements in the script
* An Implicitly wait is one of the ways to request selenium not throw any exception until provided time.
* If the element is found before implicitly wait time, selenium moves to the next commands in the program without waiting further, this wait is also called dynamic wait. If element not present it throws Nosuchelement exception
---------------------------------------------------------------------------------------------------------
31. How can we get a text of a web element?
Get command is used to get the inner text of the specified web element. The get command doesn't require any parameter, but it returns a string type value.
---------------------------------------------------------------------------------------------------------
32. What is POM (Page Object Model)? What are its advantages?
Page Object Model is a design pattern for creating an Object directory for web UI elements. Each web page is required to have its page class. The page class is responsible for finding the WebElements in web pages and then perform operations on WebElements.
---------------------------------------------------------------------------------------------------------
33. The benefits of using POM are as follows.
It facilitates with separate operations and flows in the UI from Verification - improves code readability
Multiple tests can use the same Object Repository because the Object Repository is independent of Test Cases.
Re-usability of code
---------------------------------------------------------------------------------------------------------
34. How to capture screenshot in WebDriver?
from selenium import webdriver
driver = webdriver.Chrome(r"C:\Users\srikanth\Desktop\IT\Python\python_practice\_selenium\chromedriver.exe")
driver.get("http://demowebshop.tricentis.com/")
driver.get_screenshot_as_file(r'C:\Users\srikanth\Desktop\IT\Python\python_practice\_selenium\__selanium\google.png')
---------------------------------------------------------------------------------------------------------
35. How can you find if an element is displayed on the screen?
isDisplayed()
isSelected()
isEnabled()
---------------------------------------------------------------------------------------------------------
36. How do you check broken links
Links that are not reachable are known as broken links. They may be unavailable or inoperable due to a server issue.
if we are not getting proper response from webpage it will get error or file no fount(404)
---------------------------------------------------------------------------------------------------------
37. Window handle
The window handle is a unique identifier that stores the values of windows opened on a webpage and helps in window
handling in Selenium. getWindowHandles( ) and getWindowHandles( ) handle windows in Selenium. The user has to switch
from the parent window to the child window to work on them using switchTo().window(child_window); method.

from selenium import webdriver
from time import sleep
import re
driver = webdriver.Chrome(r"C:\Users\srikanth\Desktop\IT\Python\python_practice\_selenium\chromedriver.exe")
driver.get("http://demowebshop.tricentis.com/")

'''Twitter'''
# driver.find_element_by_xpath("//a[text()='Twitter']").click()
# sleep(5)
# h = driver.window_handles
# driver.switch_to.window(h[1])
# sleep(5)
#
# driver.find_element_by_xpath("//input[@placeholder='Search Twitter']").send_keys("srikanth")
# driver.switch_to.window(h[0])
# sleep(5)
# driver.find_element_by_xpath("//a[text()='Log in']").click()

'''Facebook'''
driver.find_element_by_xpath("//a[text()='Facebook']").click()
sleep(5)
h = driver.window_handles
sleep(5)
driver.switch_to.window(h[1])
sleep(5)
driver.find_element_by_name("email").send_keys("srikanth@i234")
sleep(5)
driver.find_element_by_xpath("//input[@placeholder='Password']").send_keys('123456789')
sleep(5)
driver.find_element_by_xpath("//span[text()='Log In']").click()
sleep(5)
---------------------------------------------------------------------------------------------------------
38. @mark.parametrize
mark. parametrize allows one to define multiple sets of arguments and fixtures at the test function or class.

# File: test_parametrize.py
import pytest

def add(a, b):
    return a + b

# Test function using parametrize
@pytest.mark.parametrize("a, b, expected", [
    (2, 3, 5),
    (-1, 1, 0),
    (0, 0, 0),
    (10, -5, 5)
])
def test_addition(a, b, expected):
    assert add(a, b) == expected

---------------------------------------------------------------------------------------------------------
39. fixture
Fixtures are used to pass the data to the test functions
Each test can be run independently irrespective of previous test method is failed or passed
Pass data to test with return or yield statement
---------------------------------------------------------------------------------------------------------
40. Marker
Pytest's markers allow you to tag specific tests or group of tests for different purposes, such as skipping, marking for certain environments, or custom categorization. Pytest provides many inbuilt markers such as xfail, skip and parametrize.
To run tests with specific markers, you can use the -m flag followed by the marker name when running pytest.

* Skip: The test marked with @pytest.mark.skip won't be executed, and it will be reported as skipped with the reason specified.
# File: test_markers.py
import pytest

@pytest.mark.skip(reason="Skipping this test for demonstration")
def test_not_executed():
    assert False

def test_executed():
    assert True

* Specific: You can later run tests based on markers. For example: pytest -m slow will only run tests marked with @pytest.mark.slow

# File: test_markers_condition.py
import pytest

@pytest.mark.slow
def test_slow_operation():
    # Test some slow operation
    assert True

@pytest.mark.fast
def test_fast_operation():
    # Test some fast operation
    assert True

---------------------------------------------------------------------------------------------------------
41. What is Pytest
Pytest is a testing framework that allows users to write test codes using Python.
Pytest has its own way to detect the test file and test functions automatically, if not mentioned explicitly
---------------------------------------------------------------------------------------------------------
42. what are the features of pytest in python
@fixture
Works with built-in unit tests.
open source
Easy to start with and simple syntax.
---------------------------------------------------------------------------------------------------------
43. What do CI and CD mean?
CI and CD stand for continuous integration and continuous delivery/continuous deployment.

** Continuous Integration (CI):
CI is the practice of frequently integrating code changes into a shared repository. The main goal is to detect and address problems early in the development process.
a. Automated Builds: Developers push their code changes to a shared repository multiple times a day.
b. Automated Testing: Upon each code push, an automated process triggers builds and runs tests (unit tests, integration tests, etc.) on the new code.
c. Early Detection of Issues: CI helps identify integration issues, bugs, or conflicts between different code changes.

** Continuous Deployment/Delivery (CD):
CD extends CI by automating the deployment process of validated code changes to production or staging environments. It involves:

a. Continuous Deployment: Automated deployment of code changes to production as soon as they pass all tests in the CI pipeline.
b. Continuous Delivery: Similar to Continuous Deployment, but the decision to deploy to production is manual.


CI/CD Workflow:
a. Code Changes: Developers make changes to the codebase and push them to the version control system (e.g., Git).
b. CI Pipeline Triggered: This triggers the CI process, which includes:
    * Build Phase: Compiling code, resolving dependencies, etc.
    * Automated Testing: Running unit tests, integration tests, and other checks.
    * Reporting: Providing feedback on test results and code quality.
c. CD Process (if applicable): After successful CI, the CD process might involve:
    * Deployment to Staging: Deploying changes to a staging environment for further testing.
    * Manual Approval (in Continuous Delivery): Manual approval before deploying to production.
    * Deployment to Production: If all checks pass and approvals are given, deploying changes to the live environment.
d. Monitoring and Feedback: Continuous monitoring of the deployed application for issues and gathering feedback for future improvements.

Benefits:
* Reduced Risks: Early detection of issues and bugs.
* Faster Feedback Loop: Developers get immediate feedback on their code changes.
* Faster Delivery: Automating the deployment process leads to quicker and more reliable releases.
* Consistency: Ensures consistency in code quality and deployment processes across the team.
---------------------------------------------------------------------------------------------------------
44. What is a data driven framework?
Data Driven Framework is an automation testing framework in which input values are read from data files and stored into
variables in test scripts
---------------------------------------------------------------------------------------------------------
45. How to single testcases
We can run a specific test file by giving its name as an argument.
pytest-vs tasks/test_four.py::test_asdict
---------------------------------------------------------------------------------------------------------
46. Page object model(POM)
Page Object Model, also known as POM, is a design pattern in Selenium that creates an object repository for storing all web elements. It is useful in reducing code duplication and improves test case maintenance.
In Page Object Model, consider each web page of an application as a class file.
---------------------------------------------------------------------------------------------------------
47. What are different frameworks available in Python for unit testing?
Robot
PyTest
Unittest
DocTest
Nose2
Testify
---------------------------------------------------------------------------------------------------------
48. How to set up PyTest?
PyTest is a Python package that you can install using simple pip command.
---------------------------------------------------------------------------------------------------------
49. How to write unit test case in PyTest?
@pytest. mark. parametrize decorator, where we can specify the names of the arguments that will be passed to the test
function, and a list of arguments corresponding to the names.
---------------------------------------------------------------------------------------------------------
50. What is the command to run testcases in PyTest?
pytest <testcase_file.py>
---------------------------------------------------------------------------------------------------------
51. How to execute and run unit test cases?
a. Execute all test cases from all the Python files in the given directory.
pytest
b. Run all the test cases from the given Python file name.
pytest <file_name>
c. Execute specific testcase from the given Python file.
pytest <file_name>::<test_case>
---------------------------------------------------------------------------------------------------------
52. How to print console log in PyTest
Use -s option along with pytest command. If there is any print statement in your code, it will get printed on the console.
pytest <testcase_to_execute> -s
---------------------------------------------------------------------------------------------------------
53. Name search
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

driver = webdriver.Chrome(r'C:\Users\srikanth\Desktop\IT\Python\python_practice\_selenium\_pytest\chromedriver.exe')
driver.get('https://www.google.com/')
driver.find_element_by_xpath("//input[@class='gLFyf gsfi']").send_keys('shruthi ma', Keys.ENTER)
---------------------------------------------------------------------------------------------------------
54. SELENIUM VERSIONS
Selenium 1, which includes Selenium IDE, Selenium RC, and Selenium Grid.
Selenium 2, which includes Selenium IDE, Selenium Web -Driver 2.x, Selenium RC, and Selenium Grid.
Selenium 3, which includes Selenium IDE, Selenium Web-Driver 3.x, and Selenium Grid.
With Selenium 4, the IDE is revived and now its add-on is available for major web-browsers like Firefox and Chrome.
---------------------------------------------------------------------------------------------------------
55. Verification
We check whether we are developing the right product or not.
Verification includes different methods like Inspections, Reviews and Walkthroughes.
Quality assurance comes under verification testing.
Verification is done before the validation testing.
---------------------------------------------------------------------------------------------------------
56. Validation
We check whether the developed product is right.
Validation includes testing like functional testing, system testing, integration, and User acceptance testing.
Quality control comes under validation testing.
After verification testing, validation testing takes place.
---------------------------------------------------------------------------------------------------------
57. What is data driven and keyword driven framework in Selenium?
Data driven testing conduct tests by using several stored data, values and variables. Keyword driven testing conduct
tests by using specific keywords.
---------------------------------------------------------------------------------------------------------
58. What is Automation?
Automation is any action that can reduce human efforts.
---------------------------------------------------------------------------------------------------------
59. What all things can you automate?
• Regression test suite
• Smoke / Sanity test suite
• Build deployment
• Test data creation
• Automating behind the GUI like testing of APIs and methods.
---------------------------------------------------------------------------------------------------------
60. When is Automation testing useful?
Automation testing is useful in the following scenarios:
a) Regression testing: In case of a bug fix or new module implementation, we have to make sure that the already
implemented or unchanged functionality is not affected. In this case, we end up running the regression test case
multiple times.
For Example: After each change request or bug fix, after each iteration in case of incremental development approach, etc.

b) Non-functional Testing: Testing the non-functional aspects of an application.
For Example, Load testing or performance testing

c) Repeated execution of the same tests: Sometimes, we have to run the same set of test case for a different set of data
or after each build release or on multiple hardware, software or combination of both.
Automating the test cases in the above scenarios helps in achieving the speed of testing and minimizing human errors.
---------------------------------------------------------------------------------------------------------
61. Can you achieve 100% automation?
100% automation would be difficult to achieve because there would be many edge test cases and some cases that
are executed rarely. Automating these cases which are not executed that often will not add value to the automated suite.
---------------------------------------------------------------------------------------------------------
62. How do you decide which tool you have to use?
Concluding which tool is the best suitable for the project requires a lot of brainstorming and discussions.
---------------------------------------------------------------------------------------------------------
63. What is a framework?
A framework is a set of the structure of the entire automation suite. It is also a guideline, which if followed can result in a structure that is easy to maintain and enhance.
These guidelines include:
• Coding standards
• Handling the test data
• Maintaining and handling the elements (object repository in QTP)
• Handling of environment files and properties file
• Reporting of data
• Handling logs
---------------------------------------------------------------------------------------------------------
64. Can you do without a framework?
Frameworks are guidelines and not mandatory rules, so we can do without a framework, but if we create it and follow it,
enhancing and maintaining would be easy to implement.
---------------------------------------------------------------------------------------------------------
65. What are the different types of the Automation tool that you are aware of?
Open source tool like Selenium, JMeter, Jenkins, Postman, Polarion (Manual testing)

Paid tools like QTP, Load Runner, Ranorex, RFT, and Rational Robot.
---------------------------------------------------------------------------------------------------------
66. Where will you maintain information like URL, login, password?
This information should always be maintained in a separate file.config
---------------------------------------------------------------------------------------------------------
67. Why do you want to keep this kind of information in a separate file and not directly in the code?
URL, Login, and passwords are the kind of fields that are used very often and these change as per the environment
and authorization. In case we hardcode it into our code, we have to change it in every file which has its reference.
In case if there are more than 100 files, then it becomes very difficult to change all the 100 files and this, in turn,
can lead to errors. So this kind of information is maintained in a separate file so that updating becomes easy
---------------------------------------------------------------------------------------------------------
68. What are the different types of frameworks?
Different types of frameworks includes:
• Keyword-driven framework: Keyword driven testing conduct tests by using specific keywords.
• Data-Driven framework: Data driven testing conduct tests by using several stored data, values and variables
• Hybrid Framework: Hybrid Driven Framework is a mix of both the Data-Driven and Keyword Driven frameworks.
• Linear Scripting
---------------------------------------------------------------------------------------------------------
69. Can you tell some good coding practices while automation?
Some good coding practices include:
• Add appropriate comments.
• Identify the reusable methods and write it in a separate file.
• Follow the language-specific coding conventions.
• Maintain the test data in a separate file.
• Run your scripts regularly.
---------------------------------------------------------------------------------------------------------
70. Any kind of test which you think should not be automated?
• Exploratory testing
• Usability testing
• Test which is executed quickly when done manually.
---------------------------------------------------------------------------------------------------------
71. Which test cases can be automated?
Types of test cases which can be automated are:
(i) Smoke test cases: Smoke testing is also known as build verification testing. Smoke test cases are run every time
when a new build is released to check the health of the build for acceptance to perform testing.

(ii) Regression Test Cases: Regression testing is the testing to ensure that previously developed modules are functioning
as expected after a new module is added or a bug is fixed.
Regression test cases are very crucial in incremental software approach where a new functionality is added at each
increment phase. In this case, regression testing is performed at each incremental phase.

(iii) Non-functional test cases: Test cases like load tests and performance tests require a simulated environment
with multiple users and multiple hardware or software combinations.
Setting up multiple environments manually is impossible for each combination or number of users. Automated tools
can easily create this environment to perform non-functional testing easily.
---------------------------------------------------------------------------------------------------------
72. What are the important modules of an automation testing framework ?
Important modules of an Automation testing framework are:
1. Test Assertion Tool: This tool will provide assert statements for testing the expected values in the application
    under test. For Example. TestNG, Junit, etc.
2. Data Setup: Each test case needs to take the user data either from the database or from a file or embedded in the
    test script. Frameworks data module should take care of the data intake for test scripts and the global variables.
    eg. python, selenium, Pytest Framework, browser driver
3. Build Management Tool: Framework needs to be built and deployed for the use of creating test scripts.
4. Continuous integration tool: With CICD (Continuous Integration and Continuous Development) in place, continuous
    integration tool is required for integrating and deploying the changes done in the framework at each iteration.
5. Reporting tool: A reporting tool is required to generate a readable report after the test cases are executed for
    a better view of the steps, results, and failures. eg. pip install pytest-html
6. Logging tool: The logging tool in framework helps in better debugging of the error and bugs.
---------------------------------------------------------------------------------------------------------
73. plugins
pip install pytest
pytest --version
pip install pytest-dependency (@mark.dependency)
pip install pytest-html
skip = @py.test.mark.skip
report: pytest --html=report.html
---------------------------------------------------------------------------------------------------------
74. Web browser
A web browser (also referred to as an Internet browser or simply a browser) is application software for accessing the
World Wide Web or a local website. Firefox, Chrome, IE, and Safari
---------------------------------------------------------------------------------------------------------
75. Webdriver
Selenium WebDriver is a collection of open source APIs which are used to automate the testing of a web application.
Selenium WebDriver tool is used to automate web application testing to verify that it works as expected. It supports
many browsers such as Firefox, Chrome, IE, and Safari
---------------------------------------------------------------------------------------------------------
76. Product backlog: Features you want to implement but have not yet prioritized for release.
The Product Backlog contains all the items in the software development project.
---------------------------------------------------------------------------------------------------------
77. Sprint backlog: User stories that need to be completed during a specific period of time.
The Sprint Backlog contains only the items of the Backlog specific to the current Sprint.
---------------------------------------------------------------------------------------------------------
78. Agile meetings
1. Sprint planning meeting: Assign the task to each engineer
2. Daily standup meeting(scrum)
3. Sprint review meeting: The sprint review allows your team to demonstrate a working model of the software to the audience
4. Sprint retrospective meeting (Agile retrospective): The sprint retrospective is a recurring meeting held at the end
of a sprint used to discuss what went well during the previous sprint cycle and what can be improved for the next sprint.
---------------------------------------------------------------------------------------------------------
79. how to start automation testing with selenium
a. Decide What Test Cases to Automate
Repetitive tests that run for multiple builds.
Tests that tend to cause human error.
Tests that require multiple data sets.

b. Select the Right Automated Testing Tool
Selecting an automated testing tool is essential for test automation. There are a lot of automated testing tools on
the market, and it is important to choose the automated testing tool that best suits your overall requirements.

c. Divide Your Automated Testing Efforts
Usually, the creation of different tests is based on the QA engineers’ skill levels.

d. Create Good, Quality Test Data
This data might be read from a database or any other data source like text or XML files, Excel sheets, and database tables.
---------------------------------------------------------------------------------------------------------
80. Libraries
a. xlrd: xlrd is a module that allows Python to read data from Excel files.
b. JSON: The json library can parse JSON from strings or files. The library parses JSON into a Python dictionary or list. It can also convert Python dictionaries or lists into JSON strings.
c. csv: The csv module implements classes to read and write tabular data in CSV format.
---------------------------------------------------------------------------------------------------------
81. What is Selenium WebDriver?
Selenium WebDriver is a web framework that permits you to execute cross-browser tests. This tool is used for automating web-based application testing to verify that it performs expectedly. Selenium WebDriver allows you to choose a programming language to create test scripts.
---------------------------------------------------------------------------------------------------------
82. What is cross browser testing?
Cross Browser testing is a type of non-functional testing that lets you check whether your website works as intended
when accessed through: Different Browser-OS combinations i.e., on popular browsers like Firefox, Chrome, Edge,
Safari—on any of the popular operating systems like Windows, macOS, iOS and Android.
---------------------------------------------------------------------------------------------------------
83. Pytest - Grouping the Tests
Pytest allows us to use markers on test functions. Markers are used to set various features/attributes to test functions.
Pytest provides many inbuilt markers such as xfail, skip and parametrize.
---------------------------------------------------------------------------------------------------------
84. logger
a. error: This status is assigned to tests that caused an exception from the tested source code.
b. failed: If at least one child test fails, all its parent tests are marked as failed.
c. passes: Test passed successfully.
d. skip: The simplest way to skip a test function (@pytest.mark.skip)
e. Expected failure (xfail): An xfail means that you expect a test to fail for some reason. (@pytest.mark.xfail). A common example is a test for a feature not yet implemented, or a bug not yet fixed. When a test passes despite being expected to fail (marked with pytest. mark. xfail ), it's an xpass and will be reported in the test summary.
f. Expected pass(xpass): When a test passes instead of expected to fail (marked with pytest. mark. xfail ), it's an xpass and will be reported in the test summary.
---------------------------------------------------------------------------------------------------------
85. What is pytest-dependency?
This pytest plugin manages dependencies of tests. It allows to mark some tests as dependent from other tests. These tests will then be skipped if any of the dependencies did fail or has been skipped.
pip install pytest-dependency
Both the tests are decorated with mark.dependency()
---------------------------------------------------------------------------------------------------------
86. How do you run failed test cases in pytest?
The plugin provides two command line options to rerun failures from the last pytest invocation:
--lf , --last-failed - to only re-run the failures.
--ff , --failed-first - to run the failures first and then the rest of the tests.
---------------------------------------------------------------------------------------------------------
87. Functional and non-functional testing
Functional testing verifies each function/feature of the software whereas Non Functional testing verifies non-functional aspects like performance, usability, reliability.
Functional requirements explain how the system must work, while non functional requirements explain how the system should perform.
Functional testing is done based on the business requirement. Non- functional testing is done based on the customer expectation and Performance
---------------------------------------------------------------------------------------------------------
88. Scooping of fixture
Pytest fixture have five different scoop. Function, module, class, package and session
The scoop basically control how each fixture will be control
---------------------------------------------------------------------------------------------------------
89. The discovery of fixture
The discovery of fixture functions starts at test classes, then test modules, then conftest.py files.
---------------------------------------------------------------------------------------------------------
90. Setup/Teardown
Statements before yield keyword run’s once before every test function and statements after yield keyword run’s once after every test function. Thus, fixture acting as setup and tear down method.
---------------------------------------------------------------------------------------------------------
91. Exploring pytest command line options
python -m pytest: You can invoke testing through python interpreter from the command line.
pytest –fixtures: This will give you available fixtures
pytest -h or pytest –help: This shows help on command line and config-line options
pytest -x: This command stops execution after the first failure.
pytest –maxfail=n: This command stops execution after nth failure. n can be any number such as 1.2.3
pytest test_login: This command helps to run tests by specifying the module name.
pytest directory_name/: This command runs the tests from the directory
---------------------------------------------------------------------------------------------------------
92. Select class in selenium
* All list box related methods are implemented inside the class “Select”.
* In order to access methods of ”Select” class, we need to create an object instance to the ”Select” class and pass
a “WebElement” (list box) as constructor argument.

driver = webdriver.Chrome(r"C:\Users\hp\Desktop\IT\Testing\_selenium_files\_pytest\chromedriver.exe")

driver.get("file:///C:/Users/srikanth/Downloads/demo.html")
cars = driver.find_element_by_id("standard_cars")
s = Select(cars)
all_option = s.options


* There are 3 different methods available in “Select” class to select an item from the list box.
1. select_item_by_visible_text

s.select_by_visible_text("Audi")
sleep(1)
s.select_by_visible_text("Toyota")
sleep(1)

2. select_item_by_index

s.select_by_index(4)
sleep(1)
s.select_by_index(6)
sleep(1)

3. select_by_value

s.select_by_value('jgr')
sleep(1)
s.select_by_value('lr')
sleep(1)
---------------------------------------------------------------------------------------------------------
93. "Options" in select element
* Returns the list of all the options (each option is a WebElement) present in the list box.
* Each item of the list is an option element (WebElement).
* To get the text of all the options, we need to iterate over the list that is returned by options method and call the attribute “text” on each item of the list.

cars = driver.find_element_by_id("standard_cars")
s = Select(cars)
all_option = s.options

for item in all_option:
    print(item.text)
    sleep(2)
driver.close()
---------------------------------------------------------------------------------------------------------
94. How to handle alert and popups
The two major tasks in alerts are accepting an alert or dismissing a alert.

Alert(driver).accept()
Alert(driver).dismiss()
---------------------------------------------------------------------------------------------------------
95. Alert Methods
The major methods during handling of alerts in Selenium include –

accept() – Accepts the alert available.
dismiss() – Dismisses the alert available.
send_keys(keysToSend) – Send Keys to the Alert.
text – Gets the text of the Alert.
---------------------------------------------------------------------------------------------------------
96. Iframe work
* An iFrame (Inline Frame) is an HTML document embedded inside the current HTML document or a website
* iFrame is defined by an <iFrame></iFrame> tag in HTML. With this tag you can identify an iFrame while inspecting the HTML tree
---------------------------------------------------------------------------------------------------------
97. What is Selenium WebDriver? How does it work?
Selenium WebDriver is a powerful tool in the Selenium suite designed to automate web application testing. It allows you to interact with web elements, simulate user actions, and automate browser-based tasks across various browsers and platforms.

How Selenium WebDriver Works:
* Browser Control: WebDriver communicates directly with the browser using its native support (via browser-specific drivers) to perform actions.
* Commands and Interactions: It uses a set of commands (methods) to interact with elements on a webpage. These commands include finding elements, clicking, typing, selecting, etc.
* Language Bindings: WebDriver provides language-specific bindings (like Python, Java, JavaScript, etc.) to interact with the browser through the WebDriver API.
* Locators: WebDriver uses locators (such as XPath, CSS selectors, IDs, etc.) to identify and interact with elements on the web page.
* Execution: Tests are written as code using WebDriver's methods and executed by calling the appropriate WebDriver methods in the chosen programming language.
* Cross-Browser Compatibility: WebDriver supports multiple browsers, enabling cross-browser testing of web applications.

Core Functionality:
* Finding Elements: WebDriver provides methods like findElement() and findElements() to locate elements based on various attributes.
* Performing Actions: It allows interactions with elements such as clicking buttons, typing text, selecting options, and more using methods like click(), sendKeys(), select(), etc.
* Navigation: WebDriver enables navigation through methods like get(), navigate().to(), navigate().back(), navigate().forward(), and navigate().refresh().
* Handling Alerts, Frames, and Windows: WebDriver can handle alerts, frames, and multiple browser windows or tabs.
* Waits: It provides different types of waits (implicit, explicit, and fluent waits) to handle synchronization issues and wait for elements to load before performing actions.
---------------------------------------------------------------------------------------------------------
98. Explain different WebDriver methods for element identification.
1. find_element(By, value):
Description: Finds the first web element within the current context using the given locator.
element = driver.find_element(By.ID, "elementId")

2. find_elements(By, value):
Description: Finds all web elements within the current context using the given locator.
elements = driver.find_elements(By.CLASS_NAME, "someClass")

Locators from the By Class in Python:

* ID: By.ID
element = driver.find_element(By.ID, "elementId")

* Name: By.NAME

* Class Name: By.CLASS_NAME

* Tag Name: By.TAG_NAME

* Link Text: By.LINK_TEXT

* Partial Link Text: By.PARTIAL_LINK_TEXT

* CSS Selector: By.CSS_SELECTOR
element = driver.find_element(By.CSS_SELECTOR, "div.container input[type='text']")

* XPath: By.XPATH
element = driver.find_element(By.XPATH, "//div[@class='parent']/following-sibling::div")
-------------------------------------------------------------------------------------------------------
99. Explain the advantages and disadvantages of XPath vs. CSS selectors.
Advantages of XPath:
* Powerful Selection Capability: XPath allows for very complex and flexible element selection. It can traverse the entire document structure, allowing you to select elements based on various attributes, positions, text, and more.
* Support for Traverse and Axes: It offers traverse functionalities (parent, child, sibling, etc.) and axes to select elements in relation to other elements.
* Text-Based Selection: XPath provides functions to select elements based on their text content, making it useful for dynamic or changing content.

Disadvantages of XPath:
* Performance: In some cases, XPath can be slower compared to CSS selectors, especially for complex and lengthy XPath expressions.
* Browser Compatibility: XPath engine may behave differently across browsers, leading to inconsistencies in test execution.

Advantages of CSS Selectors:
* Performance: CSS selectors are generally faster than XPath, especially in modern browsers, as they are natively supported.
* Simplicity and Readability: CSS selectors are often more concise and easier to read than complex XPath expressions, especially for simple selection tasks.
* Browser Compatibility: CSS selectors are more consistent across browsers, providing more reliable test execution.

Disadvantages of CSS Selectors:
* Limited Traversal Capability: CSS selectors are limited in their ability to traverse the DOM, making it challenging to select elements based on their relationships or positions in the document.
* Attribute Selection Limitation: They may have limitations in selecting elements based on non-attribute properties or text content.

When to Use Which:

Use XPath when:
* Selecting complex structures or navigating through the document.
* Needing more powerful selection capabilities.
* Dealing with dynamic content where text-based selection is required.
* Use CSS Selectors when:

Selecting simple elements or classes.
* Prioritizing better performance, especially in modern browsers.
* Ensuring consistent behavior across browsers.
---------------------------------------------------------------------------------------------------------
101. What are the common challenges in Selenium automation, and how do you handle them?
* Dynamic Elements:
Challenge: Elements with dynamic IDs, names, or attributes can make test scripts brittle and prone to failure.
Solution: Use other attributes like classes, CSS selectors, or XPath expressions that are less likely to change. Implement dynamic waits (explicit waits) to ensure the element is present before interacting with it.

* Cross-Browser Compatibility:
Challenge: Web applications may behave differently across browsers, causing tests to fail on certain browsers.
Solution: Perform cross-browser testing by running tests across multiple browsers (Chrome, Firefox, Edge, etc.). Implement conditional statements or configurations for browser-specific behavior.

* Handling Frames and Pop-Ups:
Challenge: Switching between frames, handling pop-ups, or working with iframes can be challenging.
Solution: Use switch_to.frame() to switch to frames and Alert class to handle pop-ups. Handle frames and pop-ups based on their IDs, names, or index positions.

* Handling Asynchronous Behavior:
Challenge: Page load delays, AJAX calls, or dynamic content loading might cause synchronization issues.
Solution: Use explicit waits (WebDriverWait) to wait for specific conditions before interacting with elements. Implement dynamic waits for elements to be visible, clickable, or present.

* Maintaining Test Scripts:
Challenge: Maintaining and managing a large number of test scripts becomes cumbersome over time.
Solution: Follow best practices like the Page Object Model (POM) to create reusable and maintainable test scripts. Organize tests into modular components to enhance maintainability.

* Test Data Management:
Challenge: Managing test data for different test scenarios can be complex.
Solution: Use data-driven testing techniques by externalizing test data into separate files (CSV, Excel, databases). Leverage data providers or fixtures to handle test data efficiently.

* Flakiness of Tests:
Challenge: Tests intermittently failing due to environmental factors, race conditions, or network issues.
Solution: Implement robust and stable locators. Retry failed tests judiciously using frameworks like pytest-retry. Investigate and handle test failures with clear logging and error reporting.

* Performance and Execution Time:
Challenge: Long test execution times impacting continuous integration and feedback cycles.
Solution: Optimize tests for performance by minimizing unnecessary waits, avoiding unnecessary interactions, and executing tests in parallel to reduce overall execution time.
---------------------------------------------------------------------------------------------------------
102. How do you manage dynamic elements in Selenium?
* Use Stable Attributes:
Identify elements based on attributes that are less likely to change, such as data-testid, data-* attributes, or unique classes.
* XPath and CSS Selectors:
XPath: Use XPath expressions that aren't tied to specific attributes but focus on element structure or other stable attributes.
CSS Selectors: Leverage CSS selectors based on element hierarchy or other reliable attributes.
* Partial Matches:
Use partial matching in locators when a part of an attribute value remains constant.
XPath: //*[contains(@class, 'partialClassName')]
CSS: .partialClassName
* Dynamic Waits:
Implement explicit waits (WebDriverWait) to wait for the presence, visibility, or specific condition of an element before interacting with it. This helps handle elements loading asynchronously.
* Relative XPath and CSS:
Use XPath or CSS selectors based on nearby or parent elements to reach the target dynamic element. For example:
XPath: //div[@id='parent']/following-sibling::div
CSS: #parent + div
* Page Object Model (POM):
Implement the Page Object Model pattern, separating page elements and their interactions into dedicated classes. This allows quick updates if the element locators change.
* Regular Maintenance:
Periodically review and update locators in the automation codebase as the application evolves. Monitor the stability of locators and adapt them accordingly.
---------------------------------------------------------------------------------------------------------
103. Discuss Page Object Model (POM) and its advantages.
The Page Object Model (POM) is a design pattern used in test automation, particularly with Selenium, to create a structured and maintainable framework for web UI testing. It emphasizes the concept of separating the representation of web pages and their functionalities from the actual test logic.

Key Components of Page Object Model:
Page Classes:
Each web page or component in the application has a corresponding Page Class that encapsulates its elements and actions.
Page Classes represent the structure and behavior of the web page, including locators and methods to interact with those elements.

Reusable Methods:
Methods within Page Classes encapsulate the interactions with the elements on that page.
These methods provide a higher level of abstraction, making test scripts more readable and maintainable.

Advantages of Page Object Model (POM):
* Modularity and Reusability:
Promotes code reusability by encapsulating page functionalities into separate classes, making it easier to maintain and update.
* Enhanced Readability:
Test scripts become more readable and maintainable as the complex interactions with web elements are abstracted into methods within Page Classes.
* Easy Maintenance:
Facilitates easier maintenance by isolating changes to page locators or functionalities within their respective Page Classes, reducing the impact on test scripts.
* Reduced Code Duplication:
Eliminates duplication of code by centralizing element locators and interactions, making it easier to update if the structure of the web page changes.
* Improved Collaboration:
Promotes collaboration between testers and developers as Page Classes provide a clear interface defining the available actions and elements on the page.

E.g.

class LoginPage:
    def __init__(self, driver):
        self.driver = driver
        self.username_locator = "username"
        self.password_locator = "password"
        self.login_button_locator = "loginButton"

    def enter_username(self, username):
        self.driver.find_element_by_id(self.username_locator).send_keys(username)

    def enter_password(self, password):
        self.driver.find_element_by_id(self.password_locator).send_keys(password)

    def click_login(self):
        self.driver.find_element_by_id(self.login_button_locator).click()
---------------------------------------------------------------------------------------------------------
104. Explain how to handle alerts, frames, and multiple windows in Selenium.
* To Handle Alerts: Use the switch_to.alert() method to switch to the alert and perform actions.
driver.switch_to.alert.accept() - Accept the alert.
driver.switch_to.alert.dismiss() - Dismiss the alert.
driver.switch_to.alert.text - Get the text of the alert.

* To Handle Multiple Windows: Use the window handles and switch_to.window() method to switch between windows.
driver.window_handles - Get all window handles.
driver.switch_to.window(window_handle) - Switch to the desired window by its handle.
---------------------------------------------------------------------------------------------------------
106. How do you perform cross-browser testing using Selenium?
from selenium import webdriver
# Chrome
chrome_driver_path = '/path/to/chromedriver'
chrome_options = webdriver.ChromeOptions()
# Configure Chrome options if needed
chrome_driver = webdriver.Chrome(executable_path=chrome_driver_path, options=chrome_options)

# Firefox
firefox_driver_path = '/path/to/geckodriver'
firefox_options = webdriver.FirefoxOptions()
# Configure Firefox options if needed
firefox_driver = webdriver.Firefox(executable_path=firefox_driver_path, options=firefox_options)

# Perform tests using both drivers
chrome_driver.get('https://example.com')
firefox_driver.get('https://example.com')

# Execute test scenarios on both browsers
# ...
---------------------------------------------------------------------------------------------------------
107. Explain the concept of headless browsers and their use in Selenium.
Headless browsers are web browsers without a graphical user interface (GUI). They allow automated browsing and testing of web pages without actually rendering the content visually.

** Advantages of Using Headless Browsers in Selenium:
* Faster Execution: As there is no GUI rendering, tests and automation tasks run faster than in traditional browsers.

* Resource Efficiency: They consume fewer system resources (CPU and memory) compared to regular browsers, allowing more efficient use in CI/CD environments.

* Parallel Execution: Headless browsers enable easier parallel execution of tests due to their lightweight nature, improving overall test suite performance.

E.g.

from selenium import webdriver

chrome_options = webdriver.ChromeOptions()
chrome_options.add_argument("--headless")  # Enable headless mode

driver = webdriver.Chrome(r"C:\Users\hp\Desktop\IT\Testing\Selenium_Class\Chromedriver\chromedriver.exe")
driver.get("https://google.com")
---------------------------------------------------------------------------------------------------------
108. What are common exceptions you encounter in Selenium? How do you handle them?
1. NoSuchElementException:
Cause: Occurs when WebDriver cannot locate an element.
Handling: Use explicit waits (WebDriverWait) to wait for the element to be present, visible, or clickable before interacting with it. Implement try-except blocks to handle this exception by either retrying the action or handling it gracefully.

2. TimeoutException:
Cause: Occurs when WebDriver waits for an element to be available or perform an action within a specified timeout period but exceeds the defined time.
Handling: Increase the timeout duration using explicit waits or adjust the waiting conditions. Implement retries or introduce additional synchronization strategies to handle slow-loading elements.

3. StaleElementReferenceException:
Cause: Occurs when the element reference becomes stale or invalid due to the page being refreshed or modified after the element was located.
Handling: Use try-except blocks with a retry mechanism to re-locate the element or refresh the page before interacting with the element again.

4. ElementNotInteractableException:
Cause: Occurs when an element is present on the page but not in a state to be interacted with (e.g., hidden, disabled, or overlapped by another element).
Handling: Ensure the element is in an intractable state (visible, enabled) before performing actions. Adjust test logic to handle scenarios where the element might not be intractable.

5. WebDriverException:
Cause: A generic exception that covers a range of WebDriver-related issues like session not created, server not reachable, etc.
Handling: Handle specific cases based on the error message or stack trace provided in the exception. Implement robust exception handling to log details and handle exceptions gracefully.

6. UnexpectedAlertPresentException:
Cause: Occurs when an unexpected alert is present on the page.
Handling: Use switch_to.alert to handle the alert by accepting, dismissing, or getting the text. Use try-except blocks to handle alerts as needed based on test scenarios.

7. SessionNotCreatedException:
Cause: Occurs when WebDriver is unable to create a new session or instance of the browser due to driver or system configuration issues.
Handling: Review and resolve driver compatibility issues, ensure drivers are updated, and check for any system configurations causing conflicts.
---------------------------------------------------------------------------------------------------------
109. Explain how you debug Selenium tests.
1. Logging and Reporting:
WebDriver Logs: Enable WebDriver logs to capture detailed information about interactions with the browser and any errors encountered.
Custom Logging: Implement logging within your test scripts to track the flow of execution, capture specific actions, and log important information or errors.
2. Assertions and Verifications:
Use assert statements to verify expected conditions or outcomes at critical points in the test script. This helps pinpoint where failures occur.
3. Interactive Debugging:
Pause Execution: Introduce breakpoints or pauses (using time.sleep() or input() statements) in the test script to pause execution at specific points, allowing you to inspect the state of the application or browser.
Interactive Console: Leverage the browser's developer console or interactive Python consoles like IPython or Jupyter Notebook to execute commands interactively and inspect elements or execute commands in the context of the page.
4. Take Screenshots:
Capture screenshots at relevant points in the test or when an error occurs. This helps visualize the state of the application at the time of failure.
5. WebDriver Wait and Explicit Waits:
Use explicit waits (WebDriverWait) to ensure elements are present, clickable, or in the expected state before interacting with them. This can prevent synchronization issues.
6. Inspect Element Locators:
Review and validate the correctness of element locators (XPath, CSS selectors) used in test scripts. Tools like browser developer tools (Chrome DevTools, Firefox DevTools) can help identify and test locators.
7. Error Handling and Exception Handling:
Implement proper error handling to catch and handle exceptions gracefully. Use try-except blocks to catch specific exceptions and perform necessary actions (logging, retries, etc.) to recover or report failures.
8. Isolate the Issue:
Simplify the test case or isolate the failing scenario to reproduce the issue independently. Create a minimal reproducible example to narrow down the problem area.
9. Debugging Tools and IDEs:
Utilize debugging features available in integrated development environments (IDEs) like PyCharm, Visual Studio Code, or Eclipse, which offer debugging capabilities for Python Selenium scripts.
10. Review Stack Traces and Error Messages:
Analyze error messages, stack traces, and WebDriver logs to understand the root cause of failures or exceptions.
11. Continuous Improvement:
Regularly review and refactor test scripts for readability, maintainability, and robustness.
---------------------------------------------------------------------------------------------------------
109. How to handle Exception using python try and except

from selenium import webdriver
from selenium.common.exceptions import NoSuchElementException

# Initialize the WebDriver
driver = webdriver.Chrome(r"C:\Users\hp\Desktop\Chromedriver\chromedriver-win64\chromedriver.exe")

try:
    # Open a website
    driver.get("https://www.google.com")

    # Attempt to find an element that doesn't exist
    missing_element = driver.find_element_by_xpath("//textarea[@id='APjmmmFqb']")

except NoSuchElementException as e:
    print("Element not found:", e)

finally:
    # Close the browser window
    driver.quit()
